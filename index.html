<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Arduino Serial → Excel (Web)</title>
  <!-- SheetJS (XLSX) and FileSaver CDN -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <style>
    :root{font-family:Inter, system-ui, -apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{margin:0;padding:18px;background:#f6f8fa;color:#0b0f14}
    .card{background:#fff;border-radius:10px;padding:18px;box-shadow:0 6px 18px rgba(15,23,42,0.08);max-width:980px;margin:18px auto}
    h1{margin:0 0 8px;font-size:20px}
    p.lead{margin:0 0 14px;color:#475569}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    button{background:#0f1724;color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:#e6eef8;color:#0b3b66}
    button.warn{background:#ef4444}
    input, select{padding:8px;border-radius:8px;border:1px solid #e2e8f0}
    textarea{width:100%;height:160px;padding:10px;border-radius:8px;border:1px solid #e2e8f0;font-family:monospace}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:6px 8px;border-bottom:1px solid #eef2f7;text-align:left}
    .status{padding:8px;border-radius:8px;background:#0f1724;color:#fff;display:inline-block}
    .small{font-size:13px;color:#64748b}
  </style>
</head>
<body>
  <div class="card">
    <h1>Arduino Serial → Excel</h1>
    <p class="lead">Run this single HTML file in a Chromium-based browser (Windows/Android). It uses the Web Serial API to read your Arduino, parses lines like <code>Timestamp, Temp: 23.4°C, Humidity: 55%</code>, inserts the exact Excel formulas from your Python script, and downloads a .xlsx file.</p>

    <div class="controls">
      <label class="small">Baud:&nbsp;<input id="baud" type="number" value="9600" style="width:110px"></label>
      <button id="btnOpen">Open Port</button>
      <button id="btnClose" class="secondary" disabled>Close Port</button>
      <button id="btnWait" class="secondary" disabled>Wait for trigger</button>
      <button id="btnRead" class="secondary" disabled>Send 'l' & Read Log</button>
      <button id="btnExport" class="secondary" disabled>Export Excel</button>
      <button id="btnAuto" class="secondary" disabled>Wait → Read → Export (one click)</button>
    </div>

    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
      <div><span class="status" id="status">Port: closed</span></div>
      <div class="small">Trigger text: <code id="triggerText">File created and data written.</code> — End marker: <code id="endText">--- END OF FILE ---</code></div>
    </div>

    <h3 style="margin-top:16px;margin-bottom:8px">Live serial output</h3>
    <textarea id="log" readonly></textarea>

    <h3>Parsed rows preview</h3>
    <div id="preview"></div>

    <p class="small" style="margin-top:12px">Notes: This uses the browser's Web Serial API — Chrome / Edge on Windows works well. On Android, support varies by browser/version; if the port selection doesn't appear, try latest Chrome on Android or host the file on a secure origin (HTTPS).</p>
  </div>

<script>
// ------------------------------------------------------------------
// Web Serial + parsing + SheetJS export (single-file web replacement)
// Preserves the Excel formulas from your Python script exactly.
// ------------------------------------------------------------------
let port = null;
let reader = null;
let keepReading = false;
let readBuffer = '';
let linesCollected = [];
let parsedRows = [];

const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const previewEl = document.getElementById('preview');
const baudEl = document.getElementById('baud');
const triggerText = document.getElementById('triggerText').innerText;
const endText = document.getElementById('endText').innerText;

function appendLog(line){
  logEl.value += line + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}

function setStatus(s){ statusEl.textContent = s; }

async function openPort(){
  try{
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: Number(baudEl.value || 9600) });
    setStatus('Port: open');
    document.getElementById('btnClose').disabled = false;
    document.getElementById('btnWait').disabled = false;
    document.getElementById('btnRead').disabled = false;
    document.getElementById('btnExport').disabled = false;
    document.getElementById('btnAuto').disabled = false;

    // Setup reader pipeline
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();
    keepReading = true;
    readLoop();
  }catch(err){
    console.error(err);
    alert('Failed to open port: '+err);
  }
}

async function closePort(){
  keepReading = false;
  if(reader){
    try{ await reader.cancel(); }catch(e){}
    reader = null;
  }
  if(port){
    try{ await port.close(); }catch(e){}
    port = null;
  }
  setStatus('Port: closed');
  document.getElementById('btnClose').disabled = true;
  document.getElementById('btnWait').disabled = true;
  document.getElementById('btnRead').disabled = true;
  document.getElementById('btnExport').disabled = parsedRows.length===0;
  document.getElementById('btnAuto').disabled = true;
}

async function readLoop(){
  try{
    while(keepReading && reader){
      const { value, done } = await reader.read();
      if(done) break;
      if(value){
        readBuffer += value;
        while(readBuffer.indexOf('\n') !== -1){
          const idx = readBuffer.indexOf('\n');
          const line = readBuffer.slice(0, idx).trim();
          readBuffer = readBuffer.slice(idx+1);
          if(line.length) {
            appendLog(line);
            // collect lines during explicit readLog operation
            if(linesCollected !== null) linesCollected.push(line);
          }
        }
      }
    }
  }catch(err){
    console.error('Read loop error', err);
  }
}

async function waitForTrigger(trigger = triggerText){
  if(!port) return alert('Open a port first');
  setStatus('Waiting for trigger...');
  linesCollected = null; // temporarily stop collecting for log-reading session
  // We will monitor appendLog events via the global buffer because readLoop already appends
  // So we poll the textarea for new lines.
  return new Promise(resolve => {
    const observer = new MutationObserver(()=>{
      const text = logEl.value;
      const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
      if(lines.some(l=>l.includes(trigger))){
        observer.disconnect();
        appendLog('[trigger detected]');
        linesCollected = [];
        setStatus('Trigger found');
        resolve(true);
      }
    });
    observer.observe(logEl, {childList:true,characterData:true,subtree:true});
  });
}

async function sendChar(ch){
  if(!port) return alert('Open a port first');
  const writer = port.writable.getWriter();
  const data = new TextEncoder().encode(ch);
  await writer.write(data);
  writer.releaseLock();
}

async function readLogFromArduino(startText = triggerText, endTextLocal = endText){
  if(!port) return alert('Open a port first');
  appendLog("\n--- SENDING 'l' TO ARDUINO ---");
  // Start collecting fresh lines
  linesCollected = [];
  await sendChar('l');
  setStatus('Reading log...');

  return new Promise(resolve=>{
    const poll = setInterval(()=>{
      // check collected lines for end marker
      if(linesCollected && linesCollected.some(l=>l.includes(endTextLocal))){
        clearInterval(poll);
        appendLog('--- END OF FILE detected ---');
        // copy collected
        const copy = linesCollected.slice();
        linesCollected = [];
        parsedRows = parseLines(copy);
        renderPreview(parsedRows);
        setStatus('Log read complete');
        resolve(copy);
      }
    }, 200);
  });
}

function parseLines(lines){
  const out = [];
  for(const line of lines){
    if(line.includes('Temp') && line.includes('Humidity')){
      try{
        const parts = line.split(',');
        const ts = parts[0].trim();
        const temp_part = parts[1].split(':')[1].replace('°C','').replace('C','').trim();
        const temp = parseFloat(temp_part);
        const hum_part = parts[2].split(':')[1].replace('%','').trim();
        const hum = parseFloat(hum_part);
        if(!isNaN(temp) && !isNaN(hum)){
          out.push({ts,temp,hum});
        }
      }catch(e){
        console.warn('skip parse line', line, e);
      }
    }
  }
  return out;
}

function renderPreview(rows){
  if(rows.length===0){ previewEl.innerHTML = '<div class="small">No parsed rows yet.</div>'; return; }
  let html = '<table><thead><tr><th>#</th><th>Timestamp</th><th>Temp (°C)</th><th>Humidity (%)</th></tr></thead><tbody>';
  rows.forEach((r,i)=>{
    html += `<tr><td>${i+1}</td><td>${r.ts}</td><td>${r.temp}</td><td>${r.hum}</td></tr>`;
  });
  html += '</tbody></table>';
  previewEl.innerHTML = html;
}

function createExcel(wsName = 'Log'){
  if(parsedRows.length===0) return alert('No parsed data to export');

  const wb = XLSX.utils.book_new();
  const ws = {};
  // Helper to set cell
  function setCell(r,c,cell){
    const addr = XLSX.utils.encode_cell({c,c: c, r: r});
    ws[addr] = cell;
  }

  // Header row (row 0)
  const headers = ['#','Timestamp','Temp (°C)','Humidity (%)','Utah','Cumulative Utah'];
  for(let c=0;c<headers.length;c++){
    ws[XLSX.utils.encode_cell({r:0,c})] = {t:'s', v: headers[c]};
  }

  // Data rows start at row 1 (Excel row 2)
  for(let i=0;i<parsedRows.length;i++){
    const rowIndex = i+1; // zero-based index
    const excelRowNum = rowIndex+1; // 1-based excel row number
    // Col A (#)
    ws[XLSX.utils.encode_cell({r:rowIndex,c:0})] = {t:'n', v: i+1};
    // Col B Timestamp (as string)
    ws[XLSX.utils.encode_cell({r:rowIndex,c:1})] = {t:'s', v: parsedRows[i].ts};
    // Col C Temp
    ws[XLSX.utils.encode_cell({r:rowIndex,c:2})] = {t:'n', v: parsedRows[i].temp};
    // Col D Humidity
    ws[XLSX.utils.encode_cell({r:rowIndex,c:3})] = {t:'n', v: parsedRows[i].hum};

    // Col E Utah formula — EXACT formula from Python version (without leading '=')
    const tempCell = `C${excelRowNum}`;
    const utahFormula = `IF(${tempCell}="",0,IF(${tempCell}<1.111,0,IF(${tempCell}<2.222,0.5,IF(${tempCell}<8.889,1,IF(${tempCell}<12.222,0.5,IF(${tempCell}<15.556,0,IF(${tempCell}<18.333,-0.5,-1)))))))`;
    ws[XLSX.utils.encode_cell({r:rowIndex,c:4})] = {t:'n', f: utahFormula};

    // Col F Cumulative Utah formula: SUM(E$2:E{r})
    const cumFormula = `SUM(E$2:E${excelRowNum})`;
    ws[XLSX.utils.encode_cell({r:rowIndex,c:5})] = {t:'n', f: cumFormula};
  }

  // Range
  const totalRows = parsedRows.length + 1; // include header
  ws['!ref'] = `A1:F${totalRows}`;
  // Column widths (approx, in characters)
  ws['!cols'] = [{wch:5},{wch:20},{wch:12},{wch:12},{wch:12},{wch:16}];

  XLSX.utils.book_append_sheet(wb, ws, wsName);
  // write workbook to binary
  const wbout = XLSX.write(wb, {bookType:'xlsx', type:'array'});
  const blob = new Blob([wbout], {type:'application/octet-stream'});
  saveAs(blob, 'arduino_log.xlsx');
}

// ------------------------------------------------------------------
// UI wiring
// ------------------------------------------------------------------
document.getElementById('btnOpen').addEventListener('click', ()=>{
  if(!('serial' in navigator)){
    alert('Web Serial API not supported in this browser. Use Chrome/Edge on desktop or a Chromium build on Android.');
    return;
  }
  openPort();
});

document.getElementById('btnClose').addEventListener('click', ()=>{
  closePort();
});

document.getElementById('btnWait').addEventListener('click', async ()=>{
  await waitForTrigger(triggerText);
});

document.getElementById('btnRead').addEventListener('click', async ()=>{
  await readLogFromArduino();
});

document.getElementById('btnExport').addEventListener('click', ()=>{
  createExcel();
});

// Auto: wait for trigger, read log, export
document.getElementById('btnAuto').addEventListener('click', async ()=>{
  try{
    await waitForTrigger(triggerText);
    await readLogFromArduino();
    createExcel();
  }catch(e){ console.error(e); alert('Auto flow failed: '+e); }
});

// keep Export enabled only when parsedRows present
const exportObserver = new MutationObserver(()=>{
  document.getElementById('btnExport').disabled = parsedRows.length===0;
});
exportObserver.observe(previewEl, {childList:true,subtree:true});

// small improvement: when the user closes the page, clean port
window.addEventListener('unload', async ()=>{
  try{ if(port) await port.close(); }catch(e){}
});
</script>
</body>
</html>
